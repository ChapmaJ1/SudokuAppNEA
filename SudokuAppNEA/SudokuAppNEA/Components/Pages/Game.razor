@page "/game/{difficulty}"
@rendermode InteractiveServer
@inject NavigationManager NavigationManager
@inject UserClient UserClient
@inject DBCaller DatabaseCaller

<h1>Game</h1>

@if (board == null)
{
    <h1 style="margin-top: 100px">Loading...</h1>
}
else
{
    TimeSpan timer = DateTime.Now - launchTime;
    <h3 style="margin-left: 100px">Timer: @timer.Minutes:@timer.Seconds</h3>
    <h3 style="margin-left: 100px">Mistakes: @mistakeCount</h3>
    CheckBoard();
    @if (userCompleted == true)
    {
        <h3>Board Completed!</h3>
        SaveBoardData();
    }
    <div class="sudoku-container">
        @for (int row = 0; row < 9; row++)
        {
            <div class="sudoku-column">
                @for (int column = 0; column < 9; column++)
                {
                    int columnTemp = column; // if row and column directly used, OnSelected(9,9) would be called
                    int rowTemp = row;   // for all cells as the loop would have finished by the time of user interaction
                    string backgroundColour = GetBackgroundColour(rowTemp, columnTemp);
                   <button class="sudoku-cell-default" style="background-color: @backgroundColour" @onclick="() => OnCellSelected(rowTemp, columnTemp)">@DisplayCell(rowTemp, columnTemp)</button>
                }
            </div>
        }
    </div>

    <div class="game-btn-container-left">
        <button class="btn-primary" @onclick=SolveBoard>Solve Board</button>
        <button class="btn-primary" @onclick=CheckBoard>Check Board</button>
        <button class="btn-primary" @onclick=NavigateToMenu>Menu</button>
    </div>

    <div class="game-btn-container-right">
        <button class="btn-primary" @onclick=Reset>Reset Board</button>
        <button class="btn-primary" @onclick=GetHint>Get Hint</button>
        <button class="btn-primary" @onclick=ChangeNotesFunctionality>Notes: Off</button>
    </div>

    <div class="number-buttons-container">
        @for (int i = 1; i < 10; i++)
        {
            int temp = i; // if i directly used, ChangeCellValue(10) would be called for all button clicks
            <button class="button-cell" @onclick="() => ChangeCellValue(temp)">@i</button>
        }
        <button class="button-cell" @onclick="() => EraseValue()">Erase</button>
    </div>
}

@code {
    [Parameter]
    public string? difficulty {get; set;}
    private Cell? selectedCell;
    private Board? board { get; set; }
    private Board? solution { get; set; }
    private ForwardChecker? solver { get; set; }
    private int[,]? correctNumbers = new int[9, 9];
    private string menuUrl = "/menu";
    private bool solved;
    private bool userCompleted = false;
    private DateTime launchTime;
    private int mistakeCount;

    protected override async Task OnInitializedAsync()
    {
        await InitialiseBoardAndSolver();  // asynchronous method for API call
        launchTime = DateTime.Now;
        while (solved == false)
        {
            await Task.Delay(1000);
            StateHasChanged();
        }
    }

    private void NavigateToMenu()
    {
        NavigationManager.NavigateTo(menuUrl);
    }

    private async Task InitialiseBoardAndSolver()
    {
        await GetBoard();
        board!.InitialiseGraph();
        solver = new ForwardChecker(board);
        MakeUniqueSolution(board);
        board.SetQueue();  // initialise the board ready for solving
        InitialiseCorrectNumbers(); 
        solved = false;
    }

    private async Task GetBoard()
    {
        bool generated = false;
        BoardGeneratorAPI generator = new BoardGeneratorAPI();
        while (generated == false)
        {
            ResponseData responseData = await generator.GenerateBoard();  // fetch board from API
            for (int i=0; i<10; i++)
            {
                if (responseData.NewBoard.Grids[i].Difficulty == difficulty)
                {
                    board = generator.ConvertToBoard(responseData, i);     // no way of fetching board from API by difficulty, so this is checking whether
                    generated = true;                                   // the difficulty of the fetched board matches the desired difficulty
                    i = 10;
                }
            }
        }
    }

    private void MakeUniqueSolution(Board board)
    {
        bool unique = false;
        while (unique == false)
        {
            solver!.HasUniqueSolution();
            if (board.SolutionCount >= 2)
            {
                for (int i = 0; i < 9; i++)
                {
                    for (int j = 0; j < 9; j++)
                    {
                        if (board.Solutions[0].BoardSketch[i, j] != board.Solutions[1].BoardSketch[i, j])
                        {
                            Cell cell = board.GetCellLocation(i, j);
                            cell.Entry = board.Solutions[0].BoardSketch[i, j];
                            i = 9;
                            j = 9;
                            board.VariableNodes.Remove(cell);
                            board.Reset();
                        }
                    }
                }
                board.Solutions = new List<Board>();
                board.SolutionCount = 0;
            }
            else  // solutions = 0 for some reason
            {
                unique = true;
            }
        }
        board.InitialiseRemainingNumbers(board.GetFixedNodes());
    }

    private void InitialiseCorrectNumbers()
    {
        solver!.Solve(); // solve the board to get correct numbers + caches the result in board.Solutions
        for (int i=0; i<9; i++)  // for constant time access later on
        {
            for (int j=0; j<9; j++)
            {
                correctNumbers![i, j] = board!.Solutions[0].BoardSketch[i, j];  // set correct numbers
            }
        }
        board!.Reset();  // reset the board so that it is rendered in its initial state for the user
        board.SetQueue();
    }

    private void SaveBoardData()
    {
        // ADD AFTER SCORING SYSTEM ADDED
    }

    private string GetBackgroundColour(int column, int row)
    {
        string cellValue = DisplayCell(column, row);
        if (cellValue != "" && cellValue != correctNumbers![column, row].ToString())  // if cell is non-empty and is filled with an incorrect value
        {
            return "red";
        }
        return "white";
    }

    private string DisplayCell(int row, int column)    // change to array method for linear time rendering?
    {
        foreach (Cell cell in board!.AdjacencyList.Keys)
        {
            if (cell.Position.Item1 == row && cell.Position.Item2 == column)
            {
                if (cell.Entry != 0)
                {
                    return cell.Entry.ToString();
                }
                return "";  // displays the cell value if it is non-empty, otherwise displays nothing
            }
        }
        throw new InvalidOperationException("Cell does not exist");
    }

    private void OnCellSelected(int row, int column)   // also change to array method?
    {
        if (!solved)
        {
            foreach (Cell cell in board!.VariableNodes)
            {
                if (cell.Position.Item1 == row && cell.Position.Item2 == column)
                {
                    selectedCell = cell;
                }
            }
        }
    }

    private void ChangeCellValue(int number)
    {
        if (!solved)
        {
            selectedCell!.Entry = number;
            if (number != correctNumbers![selectedCell.Position.Item1, selectedCell.Position.Item2])
            {
                mistakeCount++;
            }
        }
    }

    private void CheckBoard()
    {
        if (solver!.CheckInvalid() == false && solver!.CheckFinished() == true && solved == false)
        {
            userCompleted = true;
            solved = true;
            UserClient.Entry = new()
            {
                Score = GenerateScore(difficulty!),
                CalendarDay = DateOnly.FromDateTime(DateTime.Now).ToString(),
                Difficulty = difficulty!,
                CompletionTime = FormatTime(),
                UserId = UserClient.User!.Id
            };
            DatabaseCaller.AddEntry(UserClient.Entry);
        }
    }
    public required int BoardID { get; set; }
    public required int Score { get; set; }
    public required string CalendarDay { get; set; }
    public required string Difficulty { get; set; }
    public required string CompletionTime { get; set; }
    public required int SessionID { get; set; }

    private int GenerateScore(string difficulty)
    {
        TimeSpan completionTime = DateTime.Now - launchTime;
        int timeScoreSubtraction = (completionTime.Minutes * 60 + completionTime.Seconds);
        int mistakeScoreSubtraction = mistakeCount * 100;
        int difficultyBonus = 0;
        if (difficulty == "Medium")
        {
            difficultyBonus = 500;
        }
        else if (difficulty == "Hard")
        {
            difficultyBonus = 1000;
        }
        return 5000 - timeScoreSubtraction - mistakeScoreSubtraction + difficultyBonus;
    }

    private string FormatTime()
    {
        TimeSpan completionTime = DateTime.Now - launchTime;
        return $"{completionTime.Minutes}:{completionTime.Seconds}";
    }

    private void EraseValue()
    {
        if (!solved)
        {
            selectedCell!.Entry = 0;
        }
    }

    private void SolveBoard()
    {
        if (!solved)
        {
            foreach (Cell cell in board!.VariableNodes)
            {
                cell.Entry = correctNumbers![cell.Position.Item1, cell.Position.Item2];  // sets the value of all cells to the correct value, ensuring they are rendered correctly 
            }
        }
        solved = true;
    }

    private void Reset()
    {
        if (!solved)
        {
            board!.Reset();
        }
    }

    private void GetHint()
    {

    }

    private void ChangeNotesFunctionality()
    {
        
    }
}