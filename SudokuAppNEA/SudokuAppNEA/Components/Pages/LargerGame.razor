@page "/largergame/{size}"
@rendermode InteractiveServer
@inject NavigationManager NavigationManager
@inject UserClient UserClient

<h1>Game</h1>

@if (board == null)
{
    <h1 style="margin-top: 100px">Loading...</h1>
}
else
{
    TimeSpan timer = DateTime.Now - launchTime; //
    <h3 style="margin-left: 100px">Time: @FormatTime()</h3>
    @if (UserClient.MistakeDetection == "On")
    {
        <h3 style="margin-left: 100px">Mistakes: @mistakeCount</h3>
    }
    <h3 style="margin-left: 100px">Hints: @hintCount</h3>
    CheckBoard();
    @if (userCompleted == true)
    {
        <h3>Board Completed!          Your Score: @GenerateScore(size!)</h3>
    }
    <div class="sudoku-container">
        @for (int row = 0; row < 9; row++)  // prints 81 square buttons in a 9x9 format
        {
            <div class="sudoku-column">
                @for (int column = 0; column < 9; column++)
                {
                    int columnTemp = column; // if row and column directly used, OnSelected(9,9) would be called
                    int rowTemp = row;   // for all cells as the loop would have finished by the time of user interaction
                    string backgroundColour = "white";
                    @if (UserClient.MistakeDetection == "On")
                    {
                        backgroundColour = GetBackgroundColour(rowTemp, columnTemp);
                    }
                    <button class="sudoku-cell-default" style="background-color: @backgroundColour" @onclick="() => OnCellSelected(rowTemp, columnTemp)">@DisplayCell(rowTemp, columnTemp)</button>
                }
            </div>
        }
    </div>

    <div class="game-btn-container-left">
        <button class="btn-primary" @onclick=SolveBoard>Solve Board</button>
        <button class="btn-primary" @onclick=CheckBoard>Check Board</button>
        <button class="btn-primary" @onclick=NavigateToMenu>Menu</button>
    </div>

    <div class="game-btn-container-right">
        <button class="btn-primary" @onclick=Reset>Reset Board</button>
        <button class="btn-primary" @onclick=GetHint>Get Hint</button>
        <button class="btn-primary" @onclick=Undo>Undo</button>
        <button class="btn-primary" @onclick=ChangeNotesFunctionality>Notes: @noteTaking</button>
    </div>

    <div class="number-buttons-container">
        @for (int i = 1; i < 10; i++)  // prints 9 numbered input buttons in a line
        {
            int temp = i; // if i directly used, ChangeCellValue(10) would be called for all button clicks
            <button class="button-cell" @onclick="() => ChangeCellValue(temp)">@i</button>
        }
        <button class="button-cell" @onclick="() => EraseValue()">Erase</button>
    </div>
}

@code {
    [Parameter]
    public string? size { get; set; }
    private Cell? selectedCell;
    private Board? board { get; set; }
    private Board? solution { get; set; }
    private ForwardChecker? solver { get; set; }
    private int[,]? correctNumbers;
    private string menuUrl = "/menu";
    private bool solved;
    private bool userCompleted = false;
    private DateTime launchTime;
    private int mistakeCount;
    private int hintCount;
    private string noteTaking = "Off";
    private MoveStack stack = new MoveStack(5);
    private DBCaller? DatabaseCaller = new DBCaller();
    private GameWrapper? GameWrapper;

    protected override async Task OnInitializedAsync()
    {
        InitialiseBoardAndSolver();  // asynchronous method for API call
        launchTime = DateTime.Now;
        while (solved == false)  // re-render the page every second while the board is not solved
        {                        // this is required to update the timer to reflect real-time
            await Task.Delay(1000);
            StateHasChanged();
        }
    }

    private void NavigateToMenu()
    {
        NavigationManager.NavigateTo(menuUrl);
    }

    private void InitialiseBoardAndSolver()
    {
        int dimension = Convert.ToInt32(size);
        board = new Board($"{size}", new int[dimension, dimension], dimension);
        correctNumbers = new int[dimension, dimension];
        board!.InitialiseGraph();
        MakeUniqueSolution(board!, dimension);
        solver = new ForwardChecker(board);
        board.SetQueue();  // initialise the board ready for solving
        InitialiseCorrectNumbers();
        GameWrapper = new GameWrapper(board!, correctNumbers!);
        solved = false;
    }

    private void MakeUniqueSolution(Board board, int dimension)
    {
        UniqueBoardGenerator generator = new UniqueBoardGenerator(board);
        generator.GenerateUniqueSolution(dimension);
        board.InitialiseRemainingNumbers(board.GetFixedNodes());  // initialises unique board
    }

    private void InitialiseCorrectNumbers()
    {
        solver!.Solve(); // solve the board to get correct numbers + caches the result in board.Solutions
        int dimension = Convert.ToInt32(size);
        for (int i = 0; i < dimension; i++)  // for constant time access later on
        {
            for (int j = 0; j < dimension; j++)
            {
                correctNumbers![i, j] = board!.Solutions[0].BoardSketch[i, j];  // set correct numbers
            }
        }
        board!.Reset();  // resets the board so that it is rendered in its initial state for the user
        board.SetQueue();
    }

    private string GetBackgroundColour(int row, int column)
    {
        return GameWrapper!.GetBackgroundColour(row, column);
    }

    private string DisplayCell(int row, int column)    // change to array method for linear time rendering?
    {
        return GameWrapper!.DisplayCell(row, column);
    }

    private void OnCellSelected(int row, int column)   // also change to array method?
    {
        selectedCell = GameWrapper!.OnCellSelected(row, column);
    }

    private void ChangeCellValue(int number)
    {
        if (!(selectedCell!.Position.Item1 == 100))
        {
            if (!solved)
            {
                mistakeCount += GameWrapper!.ChangeCellValue(number, stack, selectedCell!, noteTaking);
            }
        }        
    }

    private void CheckBoard()
    {
        if (solver!.CheckInvalid() == false && solver!.CheckFinished() == true && solved == false)
        {  // if board has been solved + not been solved in previous renders
            userCompleted = true;
            solved = true;
            if (UserClient.SaveScores == "On")  // if the user's settings indicate that the score should be saved to the database
            {
                string difficulty = $"{size}x{size}";
                UserClient.AddEntry(difficulty!, mistakeCount, FormatTime());
                DatabaseCaller!.AddEntry(UserClient.Entry!);  // creates a new record for the board entry + adds it to the database
            }
        }
    }

    private int GenerateScore(string difficulty)
    {
        TimeSpan completionTime = DateTime.Now - launchTime;
        int timeScoreSubtraction = (completionTime.Minutes * 60 + completionTime.Seconds);  // 1 score subtracted per second
        int mistakeScoreSubtraction = mistakeCount * 100;  // 100 score subtracted per mistake
        int hintScoreSubtraction = hintCount * 150;  // 150 score subtracted per hint
        int difficultyBonus = 0;
        if (size == "16")
        {
            difficultyBonus = 2000;
        }
        else if (difficulty == "25")
        {
            difficultyBonus = 5000;
        }
        int score = 5000 - timeScoreSubtraction - mistakeScoreSubtraction - hintScoreSubtraction + difficultyBonus;  // score calculation, from an initial score of 5000
        if (score < 0)
        {
            return 0;  // negative scores brought up to 0
        }
        return score;
    }

    private string FormatTime()
    {
        return GameWrapper!.FormatTime(launchTime);
    }

    private void EraseValue()
    {
        if (!solved)
        {
            selectedCell!.ChangeCellValue(0);
        }
    }

    private void SolveBoard()
    {
        GameWrapper!.SolveBoard();
        solved = true;
    }

    private void Reset()
    {
        if (!solved)
        {
            board!.Reset();
        }
    }

    private void GetHint()
    {
        hintCount++;
        GameWrapper!.GetHint();
    }

    private void ChangeNotesFunctionality()  // changes frontend display + functionality when changing cell values
    {
        noteTaking = GameWrapper!.ChangeNotesFunctionality(noteTaking);
    }

    private void Undo()
    {
        GameWrapper!.Undo(stack);
    }
}
